<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
  </body>
    <script src="js/three.js"></script>
    <script>

        var keyPressed = [];
        var C_KEY_SHIFT = 16;
        var C_KEY_CTRL = 17;
        var C_KEY_ALT = 18;

        var C_KEY_LEFT = 37;
        var C_KEY_DOWN = 40;
        var C_KEY_RIGHT = 39;
        var C_KEY_UP = 38;

        var renderer = null;
        var scene = null;
        var camera = null;

        function start()
        {

            renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            setKeyboard();

            // Init camera.
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
            camera.position.set(-25, 0, 45);
            camera.lookAt( 0, 0, 0 );

			// Init orbit
            /*var controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.target.set(0, 5, 0);
            controls.update();
            */

			// Init scene
            scene = new THREE.Scene();
			//scene.background = new THREE.Color('black');

            addLightToScene(scene);

			/*
			// Add board
            {
                var planeSize = 2;

                var loader = new THREE.TextureLoader();
                var texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.magFilter = THREE.NearestFilter;
                var repeats = planeSize / 2;
                texture.repeat.set(repeats, repeats);

                var planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
                var planeMat = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
                });
                var mesh = new THREE.Mesh(planeGeo, planeMat);
                mesh.rotation.x = Math.PI * -.5;
                scene.add(mesh);
            }

			// Add iso cube
            {
                var cubeSize = 4;
                var cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
                var cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
                var mesh = new THREE.Mesh(cubeGeo, cubeMat);
                mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
                scene.add(mesh);
            }
			*/

			addCustomObject(scene);

            animate();
        }

        function setKeyboard()
        {
            document.onkeydown = function(event) 
            {
                keyPressed[event.keyCode] = true;
                return true;
            };

            document.onkeyup = function(event) 
            {
                keyPressed[event.keyCode] = false;
                return true;
            }
        }

        function addLightToScene(_scene)
        {
            var skyColor = 0xB1E1FF;  // light blue
            var groundColor = 0xB97A20;  // brownish orange
            var intensity = 1;
            var light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            _scene.add(light);

        }

        function addMeshesToGroup(_scene)
        {
            if (typeof scene.getObjectById(mygroup.id) !== 'undefined')
                scene.remove(mygroup);

            scene.add( mygroup );
            var cube_geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var cube_material = new THREE.MeshBasicMaterial( { color: 0xFF00FF } );
            cube_mesh = new THREE.Mesh(cube_geometry, cube_material );
            cube_mesh.position.set( 0, 0, 0 );
            mygroup.add(cube_mesh);

            var cube_geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var cube_material = new THREE.MeshBasicMaterial( { color: Integert.parse("0x00FFFF") } );
            cube_mesh = new THREE.Mesh(cube_geometry, cube_material );
            cube_mesh.position.set( 0, 0, 0 );
            mygroup.add(cube_mesh);

            _scene.add( mygroup );
        }

        function addCustomObject(_scene)
        {
            var mycube_geometry = new THREE.Geometry();

            mycube_geometry.vertices.push(
                new THREE.Vector3(0.00, 0.00, 0.00),
                new THREE.Vector3(0.00, 20.00, 0.00),
                new THREE.Vector3(30.00, 20.00, 0.00),
                new THREE.Vector3(30.00, 0.00, 0.00),
                new THREE.Vector3(0.00, 0.00, 2.00),
                new THREE.Vector3(0.00, 20.00, 2.00),
                new THREE.Vector3(30.00, 20.00, 2.00),
                new THREE.Vector3(30.00, 0.00, 2.00)
            );

            mycube_geometry.faces.push( 
                new THREE.Face3( 0, 1, 2),
                new THREE.Face3( 0, 2, 3),
                new THREE.Face3( 3, 2, 6),
                new THREE.Face3( 3, 6, 7),
                new THREE.Face3( 7, 6, 5),
                new THREE.Face3( 7, 5, 4),
                new THREE.Face3( 4, 5, 1),
                new THREE.Face3( 4, 1, 0),
                new THREE.Face3( 1, 5, 6),
                new THREE.Face3( 1, 6, 2),
                new THREE.Face3( 7, 4, 0),
                new THREE.Face3( 7, 0, 3)
            );

            mycube_geometry.computeBoundingSphere();
            mycube_geometry.computeFaceNormals();

            var mycube_material = new THREE.MeshPhongMaterial({color: "#8AC"});
            var mycube_mesh = new THREE.Mesh(mycube_geometry, mycube_material );
            _scene.add( mycube_mesh );
        }
        
        function animate(_time) 
        {
            processInput();
           
            render();

            requestAnimationFrame(animate);
        }

        function processInput(time) 
        {
			var updateCamera = false;
					
            if (isKeyPressed(C_KEY_LEFT) === true)
            {
                updateCamera = true;
                camera.position.x -= 0.5;
            }

            if (isKeyPressed(C_KEY_RIGHT) === true)
            {
                updateCamera = true;
                camera.position.x += 0.5;
            }

            if (isKeyPressed(C_KEY_UP) === true)
            {
                updateCamera = true;
                
                if (isKeyPressed(C_KEY_SHIFT) === true)
                    camera.position.y += 0.5;
                else
                    camera.position.z -= 0.5;
            }

            if (isKeyPressed(C_KEY_DOWN) === true)
            {
                updateCamera = true;

                if (isKeyPressed(C_KEY_SHIFT) === true)
                    camera.position.y -= 0.5;
                else
                    camera.position.z += 0.5;
            }

            if (updateCamera === true)
            {
                //camera.up.set( 0, 0, 1 );
                camera.lookAt( 0, 0, 0 );
                camera.updateProjectionMatrix();
                console.log("x:", camera.position.x, " y:" + camera.position.y + " z:", camera.position.z);
            }


        };

        function render()
        {
            if (resizeRendererToDisplaySize(renderer)) 
            {
                var canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            renderer.render(scene, camera);
        }

        function isKeyPressed(_scanCode) 
        {
            return keyPressed[_scanCode];
        }

        function resizeRendererToDisplaySize(renderer) 
        {
            var canvas = renderer.domElement;
            var width = canvas.clientWidth;
            var height = canvas.clientHeight;
            var needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) 
            {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

		start();
    </script>
</html>
